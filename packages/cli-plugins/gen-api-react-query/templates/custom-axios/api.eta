<%
const { utils, route, config, modelTypes, myConfig  } = it;
const { _, classNameCase, pascalCase, require } = utils;
const {  RESERVED_REQ_PARAMS_ARG_NAMES } = config.constants;

const routes = route.routes;
const dataContracts = _.map(modelTypes, "name");

const projectRootPath = process.env.PWD;
const myTemeplatePath = `../my`;
const reactQueryTemplatePath = `${myTemeplatePath}/react-query-hook.eta`;
const reactSuspenseQueryTemplatePath = `${myTemeplatePath}/react-query-suspense-hook.eta`;
const reactQuerKeyTemplatePath = `${myTemeplatePath}/react-query-key.eta`;

const apiClassName = classNameCase(route.moduleName) + 'Api';
const paginationSets = myConfig?.paginationSets;
const instancePath = myConfig?.instancePath;

const includeReactQuery = myConfig?.includeReactQuery;
const includeReactSuspenseQuery = myConfig?.includeReactSuspenseQuery;

const apiInstanceName = route.moduleName + "Api";
const queryKeyName = "QUERY_KEY_" + _.upperCase(apiClassName).replace(/ /g, '_');

const hasPaginationKeyword = (queryString, keywords = paginationKeywords ) => {
  if(!includeReactQuery && !includeReactSuspenseQuery ) return false;
  const keywordUnion = keywords.map(str => `.*${str}.*`).join("|");
  const rgxSting = keywords.map(str => `(${keywordUnion})`).join("");
  const rgx = new RegExp(rgxSting);
  return rgx.test(queryString);
};

const upperSnakeCase = (str) => _.upperCase(str).replace(/ /g, '_');

const removeModuleName = (str) => str.replace(route.moduleName,'');

const getConfigByRoute = (route) => {
  const { specificArgNameResolver } = route;
  const { parameters, path, method, payload, query, formData, security, requestParams } = route.request;
  const pathParams = _.values(parameters);
  const pathParamsNames = _.map(pathParams, "name");
  const queryName = (query && query.name) || "query";

  const requestConfigParam = {
    name: specificArgNameResolver.resolve(RESERVED_REQ_PARAMS_ARG_NAMES),
    optional: true,
    type: "RequestParams",
  };

  const argToTmpl = ({ name, optional, type, defaultValue }) => `${name}${!defaultValue && optional ? '?' : ''}: ${type}`;

  const rawWrapperArgs = config.extractRequestParams ?
  _.compact([
      requestParams && {
        name: pathParams.length ? `{ ${_.join(pathParamsNames, ", ")}, ...${queryName} }` : queryName,
        optional: false,
        type: getInlineParseContent(requestParams),
      },
      ...(!requestParams ? pathParams : []),
      payload,
      requestConfigParam,
  ]) :
  _.compact([
      ...pathParams,
      query,
      payload,
      requestConfigParam,
  ]);

  const wrapperArgs = _
    // Sort by optionality
    .sortBy(rawWrapperArgs, [o => o.optional])
    .map(argToTmpl)
    .join('; ');

  const functionName = route.routeName.usage;
  const hookVariant = _.upperCase(method) === "GET" ? "Query" : "Mutation";
  const key = upperSnakeCase(functionName);
  const methodKey = upperSnakeCase(removeModuleName(functionName));
  const pagination = paginationSets.find(d => !!query?.type && hasPaginationKeyword(query?.type.split("\n").join(""), d.keywords));

  const isQuery = hookVariant === "Query";
  const isMutation = hookVariant === "Mutation";
  const hasPagination = !!pagination;

  const isOptionalVariables = _
  .filter(rawWrapperArgs, o => o.optional).length === rawWrapperArgs.length;

  const conditionalVriablesText = isOptionalVariables ? "variables?" : "variables";
  const repalceTarget = "${" + conditionalVriablesText + ".";

  return {
    conditions: {
      hasPagination,
      includeReactQuery,
      includeReactSuspenseQuery,
      isQuery,
      isMutation,
      isOptionalVariables,
    },
    data: {
      rawWrapperArgs,
      wrapperArgs,
      queryKeyName,
      functionName,
      apiInstanceName,
      apiClassName,
      hookVariant,
      key,
      methodKey,
      pagination,
    },
    utils: {
      upperSnakeCase,
      removeModuleName,
      argToTmpl,
    }
  };
};

const dataForReactHookTemplate = {
  getConfigByRoute,
  queryKeyName,
  apiClassName,
  apiInstanceName,
};
%>

<% if (config.httpClientType === config.constants.HTTP_CLIENT.AXIOS) { %> 
import { AxiosRequestConfig, AxiosResponse } from "axios"; 
<% } %>

import { AxiosError } from 'axios';
import { useQuery, useMutation, useInfiniteQuery, useSuspenseQuery, useSuspenseInfiniteQuery, InfiniteData } from '@tanstack/react-query';
import { QueryHookParams, InfiniteQueryHookParams, MutationHookParams, Parameter, RequestFnReturn, SuspenseInfiniteQueryHookParams, SuspenseQueryHookParams } from "../@types/react-query-type";
import { paramsSerializerBy } from "../@utils/param-serializer-by";

import instance from "<%= instancePath %>";
import { HttpClient, RequestParams, ContentType, HttpResponse } from "../@<%= config.fileNames.httpClient %>";
import { DeepOmitReadOnly } from '../@types/util-types';

<% if (dataContracts.length) { %>
import { <%= dataContracts.join(", ") %> } from "../@types/<%= config.fileNames.dataContracts %>";
<% } %>

/**
 * !DO NOT EDIT THIS FILE
 * 
 * 스크립트가 실행될때, 파일을 항상 새로 쓰기 때문에 파일 수정시 작성내용이 제거 될 수 있습니다.
 */

export class <%= apiClassName %><SecurityDataType = unknown><% if (!config.singleHttpClient) { %> extends HttpClient<SecurityDataType> <% } %> {
<% if(config.singleHttpClient) { %>
  http: HttpClient<SecurityDataType>;

  constructor (http: HttpClient<SecurityDataType>) {
    this.http = http;
  }
<% } %>

  <% routes.forEach((route) => { %>
    <%~ includeFile('./procedure-call.eta', { ...it, route }) %>
  <% }) %>
}

<% if(myConfig.includeReactQuery || myConfig.includeReactSuspenseQuery) { %>
  //<%= myConfig.QUERY_HOOK_INDICATOR %>

  <% if(myConfig.includeReactQuery) { %>
    /**
    * !DO NOT EDIT THIS FILE
    * 
    * 스크립트가 실행될때, 파일을 항상 새로 쓰기 때문에 파일 수정시 작성내용이 제거 될 수 있습니다.
    */

    /**
    * tok-cli.config.ts 에서 설정된 instance 경로의 axios instace 가 적용된, api 의 instance 입니다.
    */
    export const <%= apiInstanceName %> = new <%= apiClassName %>({ instance:instance });

    <%~ includeFile(reactQuerKeyTemplatePath, { ...it, route , dataFromApiTemplate:dataForReactHookTemplate}) %>

    <% routes.forEach((route) => { %>
      <%~ includeFile(reactQueryTemplatePath, { ...it, route , dataFromApiTemplate:dataForReactHookTemplate}) %>
    <% }) %>
  <% } %>

  <% if(myConfig.includeReactSuspenseQuery) { %>
    //<%= myConfig.USE_SUSPENSE_QUERY_HOOK_INDICATOR %>

    /**
    * !DO NOT EDIT THIS FILE
    * 
    * 스크립트가 실행될때, 파일을 항상 새로 쓰기 때문에 파일 수정시 작성내용이 제거 될 수 있습니다.
    */

    /**
    * tok-cli.config.ts 에서 설정된 instance 경로의 axios instace 가 적용된, api 의 instance 입니다.
    */
    export const <%= apiInstanceName %> = new <%= apiClassName %>({ instance:instance });

    <%~ includeFile(reactQuerKeyTemplatePath, { ...it, route , dataFromApiTemplate:dataForReactHookTemplate}) %>

    <% routes.forEach((route) => { %>
      <%~ includeFile(reactSuspenseQueryTemplatePath, { ...it, route , dataFromApiTemplate:dataForReactHookTemplate}) %>
    <% }) %>
  <% } %>
<% } %>

