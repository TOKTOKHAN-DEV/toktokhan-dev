import CodeBlock from '@theme/CodeBlock'

# 1. Refresh token

만료된 액세스 토큰을 처리하기 위해 구현된 리프래시 토큰 로직을 설명합니다. 
액세스 토큰이 만료되면 리프래시 토큰을 사용하여 새로운 액세스 토큰을 얻습니다. 
이 과정에는 새로운 액세스 토큰으로 원래 요청을 재시도하거나, 리프래시 프로세스가 실패한 경우 오류를 처리하는 단계가 포함됩니다.

## retryRequestManager()
똑똑한 개발자 템플릿에는 리프래시 로직을 간단하게 구현하는 데에 도와주는 `retryRequestManager()` 함수가 있습니다. 
해당 함수와 함께 리프래시 로직을 구현하는 플로우를 소개합니다.

```ts
// next-page-init/src/configs/axios/retry-request-manager.ts
retryRequestManager({
  getToken: async () => {
  },
  onRefetch: (token) => {
  },
  onError: () => {
  },
})
```


## Workflow

### 1. 토큰 만료 확인
요청이 들어오면, 시스템은 액세스 토큰이 만료되었는지 확인합니다.
```ts
instance.interceptors.response.use(
  (res) => {
    const { status, config: reqData, data: resData } = res
    return res
  },
  async (error: AxiosError) => {
    try {
      const { response: res, config: reqData } = error || {}
      const { status } = res || { status: 400 }
      const isExpiredToken = status === 444
    }
  }
  ...
)
```


### 2. getToken: 새로운 `access_token`  발급
retryRequestManager() 함수를 사용하여 재시도 매커니즘을 구현합니다.
getToken 함수를 통해 리프래시 토큰을 사용하여 새로운 액세스 토큰을 얻습니다.
```ts
getToken: async () => {
  const token = await authApi.authControllerRefresh({
    data: {
      refreshToken: tokenStorage?.get()?.refresh_token || '',
    },
  })
  tokenStorage?.set({
    access_token: token.access_token,
    refresh_token: token.refresh_token,
  })

  return token.access_token
},  
```

## 3. onRefetch: 기존 요청 재시도
onRefetch 함수를 호출하여 새로운 액세스 토큰을 헤더에 추가하고, 원래 요청을 재시도합니다.
```ts 
onRefetch: (token) => {
  if (!reqData) return Promise.reject('reqData is not exist')
  console.log('reqData', reqData)
  reqData.headers.Authorization = `Bearer ${token}`
  return instance
    .request(reqData)
    .then(() => console.log('******4. 리프래시 성공*******'))
} 
```

## 4. onError: 에러 처리

리프래시 토큰을 사용한 재시도가 실패하면, onError 함수를 호출하여 토큰을 제거하고 오류를 반환합니다.

```ts 
onError: () => {
  tokenStorage?.remove()
  return Promise.reject(error)
}
```


